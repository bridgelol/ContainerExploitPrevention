package world.minecraftservers.plugin;

import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.TextComponent;
import net.kyori.adventure.text.serializer.gson.GsonComponentSerializer;
import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.Nameable;
import org.bukkit.NamespacedKey;
import org.bukkit.block.Block;
import org.bukkit.block.BlockState;
import org.bukkit.block.TileState;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Player;
import org.bukkit.entity.Vehicle;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.event.inventory.InventoryOpenEvent;
import org.bukkit.event.player.PlayerInteractEntityEvent;
import org.bukkit.event.vehicle.VehicleCreateEvent;
import org.bukkit.event.vehicle.VehicleDestroyEvent;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.InventoryHolder;
import org.bukkit.inventory.ItemStack;
import org.bukkit.persistence.PersistentDataContainer;
import org.bukkit.persistence.PersistentDataType;
import org.bukkit.plugin.java.JavaPlugin;

import java.util.*;


enum ExemptType {
    EQUALS(String::equals), CONTAINS(String::contains), STARTS_WITH(String::startsWith);

    private final StringMatcher matcher;

    ExemptType(StringMatcher matcher) {
        this.matcher = matcher;
    }

    public StringMatcher getMatcher() {
        return matcher;
    }
}

interface StringMatcher {
    boolean matches(String o1, String o2);
}

public class ContainerExploitPrevention extends JavaPlugin implements Listener {

    private final NamespacedKey clientSideRenderTitleKey = new NamespacedKey(this, "ContainerCSRTitle");
    private final Collection<ExemptTitle> exemptTitles = new HashSet<>();

    @Override
    public void onEnable() {
        getConfig().options().copyDefaults(true);
        saveConfig();

        reload();

        Objects.requireNonNull(getCommand("containerexploitpreventionreload")).setExecutor((sender, command, label, args) -> {
            if (!sender.hasPermission("containerexploitprevention.reload")) {
                sender.sendMessage("You do not have permission to use this command!");
                return true;
            }

            reload();
            sender.sendMessage("Reloaded!");
            return true;
        });

        getServer().getPluginManager().registerEvents(this, this);

        if (Bukkit.getPluginManager().getPlugin("ProtocolLib") != null) {
            ProtocolLibHook.register(this, clientSideRenderTitleKey);
        }
    }

    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
    public void onBlockPlace(BlockPlaceEvent event) {
        Block block = event.getBlock();
        BlockState state = block.getState(false);

        if (state instanceof Nameable nameable) {
            Component customName = nameable.customName();

            if (customName != null && canUseTitle(customName)) {
                if (state instanceof TileState tileState) {
                    nameable.customName(null);
                    PersistentDataContainer pdc = tileState.getPersistentDataContainer();
                    pdc.set(clientSideRenderTitleKey, PersistentDataType.STRING, GsonComponentSerializer.gson().serialize(customName));
                }
            }
        }
    }

    @EventHandler(priority = EventPriority.LOWEST)
    public void onBlockBreak(BlockBreakEvent event) {
        Block block = event.getBlock();
        BlockState state = block.getState(false);

        if (state instanceof TileState tileState) {
            PersistentDataContainer pdc = tileState.getPersistentDataContainer();
            String serializedCustomName = pdc.get(clientSideRenderTitleKey, PersistentDataType.STRING);

            if (serializedCustomName != null) {
                if (state instanceof Nameable nameable) {
                    nameable.customName(GsonComponentSerializer.gson().deserialize(serializedCustomName));
                }
            }
        }
    }

    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
    public void onVehicleCreate(VehicleCreateEvent event) {
        Vehicle vehicle = event.getVehicle();

        if (vehicle instanceof InventoryHolder) {
            Component customName = vehicle.customName();

            if (customName != null && canUseTitle(customName)) {
                vehicle.customName(null);
                PersistentDataContainer pdc = vehicle.getPersistentDataContainer();
                pdc.set(clientSideRenderTitleKey, PersistentDataType.STRING, GsonComponentSerializer.gson().serialize(customName));
            }
        }
    }

    @EventHandler(priority = EventPriority.LOWEST)
    public void onVehicleDestroy(VehicleDestroyEvent event) {
        Vehicle vehicle = event.getVehicle();

        if (vehicle instanceof InventoryHolder) {
            PersistentDataContainer pdc = vehicle.getPersistentDataContainer();
            String serializedCustomName = pdc.get(clientSideRenderTitleKey, PersistentDataType.STRING);

            if (serializedCustomName != null) {
                vehicle.customName(GsonComponentSerializer.gson().deserialize(serializedCustomName));
            }
        }
    }

    // This is mainly for donkeys, villagers etc...
    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onOpen(InventoryOpenEvent event) {
        Inventory inventory = event.getInventory();

        if (getConfig().getBoolean("hard-patch-deluxe-combat", true)) {
            Component title = event.getView().title();

            if (title instanceof TextComponent textComponent && textComponent.content().toLowerCase().contains("deluxecombat")) {
                event.setCancelled(true);
                return;
            }
        }

        InventoryHolder holder = inventory.getHolder();

        if (holder instanceof Entity entity) {
            Component customName = entity.customName();

            if (customName != null && canUseTitle(customName)) {
                entity.customName(null);
                PersistentDataContainer pdc = entity.getPersistentDataContainer();
                pdc.set(clientSideRenderTitleKey, PersistentDataType.STRING, GsonComponentSerializer.gson().serialize(customName));
            }
        } else if (holder instanceof Nameable nameable && holder instanceof TileState tileState) {
            Component customName = nameable.customName();

            if (customName != null && canUseTitle(customName)) {
                nameable.customName(null);
                PersistentDataContainer pdc = tileState.getPersistentDataContainer();
                pdc.set(clientSideRenderTitleKey, PersistentDataType.STRING, GsonComponentSerializer.gson().serialize(customName));
            }
        }
    }

    private void reload() {
        reloadConfig();
        FileConfiguration config = getConfig();

        exemptTitles.clear();

        Map.of(ExemptType.EQUALS, config.getStringList("exempt.equals"), ExemptType.CONTAINS, config.getStringList("exempt.contains"), ExemptType.STARTS_WITH, config.getStringList("exempt.startsWith")).forEach((type, titles) -> titles.forEach(title -> exemptTitles.add(new ExemptTitle(title, type))));
    }

    private boolean canUseTitle(Component title) {
        if (!(title instanceof TextComponent textComponent)) {
            return true;
        }

        final String content = textComponent.content();
        return exemptTitles.stream().noneMatch(exemptTitle -> exemptTitle.matches(content));
    }
}

record ExemptTitle(String title, ExemptType type) {
    public boolean matches(String other) {
        return type.getMatcher().matches(title, other);
    }
}

class ProtocolLibHook {
    static void register(JavaPlugin plugin, NamespacedKey clientSideRenderTitleKey) {
        Bukkit.getLogger().info("ProtocolLib detected, enabling client-side rendering of container titles");

        com.comphenix.protocol.ProtocolLibrary.getProtocolManager().addPacketListener(new com.comphenix.protocol.events.PacketAdapter(plugin, com.comphenix.protocol.events.ListenerPriority.NORMAL, com.comphenix.protocol.PacketType.Play.Server.OPEN_WINDOW) {
            @Override
            public void onPacketSending(com.comphenix.protocol.events.PacketEvent event) {
                Inventory topInventory = event.getPlayer().getOpenInventory().getTopInventory();

                if (topInventory.getHolder() instanceof TileState tileState) {
                    PersistentDataContainer pdc = tileState.getPersistentDataContainer();
                    String serializedCustomName = pdc.get(clientSideRenderTitleKey, PersistentDataType.STRING);

                    if (serializedCustomName != null) {
                        com.comphenix.protocol.events.PacketContainer packet = event.getPacket();
                        packet.getChatComponents().write(0, com.comphenix.protocol.wrappers.WrappedChatComponent.fromJson(serializedCustomName));
                    }
                } else if (topInventory.getHolder() instanceof Vehicle vehicle) {
                    PersistentDataContainer pdc = vehicle.getPersistentDataContainer();
                    String serializedCustomName = pdc.get(clientSideRenderTitleKey, PersistentDataType.STRING);

                    if (serializedCustomName != null) {
                        com.comphenix.protocol.events.PacketContainer packet = event.getPacket();
                        packet.getChatComponents().write(0, com.comphenix.protocol.wrappers.WrappedChatComponent.fromJson(serializedCustomName));
                    }
                }
            }
        });

        com.comphenix.protocol.ProtocolLibrary.getProtocolManager().addPacketListener(new com.comphenix.protocol.events.PacketAdapter(plugin, com.comphenix.protocol.PacketType.Play.Server.ENTITY_METADATA) {
            @Override
            public void onPacketSending(com.comphenix.protocol.events.PacketEvent event) {
                com.comphenix.protocol.events.PacketContainer packet = event.getPacket();
                Entity entity = packet.getEntityModifier(event).read(0);

                if (entity instanceof InventoryHolder) {
                    PersistentDataContainer pdc = entity.getPersistentDataContainer();
                    String serializedCustomName = pdc.get(clientSideRenderTitleKey, PersistentDataType.STRING);

                    if (serializedCustomName != null) {
                        com.comphenix.protocol.wrappers.WrappedDataWatcher dataWatcher = com.comphenix.protocol.wrappers.WrappedDataWatcher.getEntityWatcher(entity).deepClone();
                        com.comphenix.protocol.wrappers.WrappedDataWatcher.Serializer chatSerializer = com.comphenix.protocol.wrappers.WrappedDataWatcher.Registry.getChatComponentSerializer(true);
                        final com.comphenix.protocol.wrappers.WrappedDataWatcher.WrappedDataWatcherObject optChatFieldWatcher = new com.comphenix.protocol.wrappers.WrappedDataWatcher.WrappedDataWatcherObject(2, chatSerializer);

                        final Optional<Object> optChatField = Optional.of(com.comphenix.protocol.wrappers.WrappedChatComponent.fromJson(serializedCustomName));

                        dataWatcher.setObject(optChatFieldWatcher, optChatField);

                        dataWatcher.setObject(3, true); // set CustomNameVisible=true
                        final List<com.comphenix.protocol.wrappers.WrappedDataValue> wrappedDataValueList = new ArrayList<>();

                        for (final com.comphenix.protocol.wrappers.WrappedWatchableObject entry : dataWatcher.getWatchableObjects()) {
                            if (entry == null) continue;

                            final com.comphenix.protocol.wrappers.WrappedDataWatcher.WrappedDataWatcherObject watcherObject = entry.getWatcherObject();
                            wrappedDataValueList.add(new com.comphenix.protocol.wrappers.WrappedDataValue(watcherObject.getIndex(), watcherObject.getSerializer(), entry.getRawValue()));
                        }

                        packet.getDataValueCollectionModifier().write(0, wrappedDataValueList);
                    }
                }
            }
        });
    }
}